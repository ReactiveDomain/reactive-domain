# IRepository Interface

[← Back to API Reference](../README.md) | [← Back to Table of Contents](../../README.md)

## Overview

The `IRepository` interface defines the contract for repositories that store and retrieve event-sourced aggregates in Reactive Domain. It is a fundamental component in the event sourcing pattern, serving as the bridge between domain aggregates and the underlying event store.

Repositories in Reactive Domain follow the Repository pattern from Domain-Driven Design (DDD), providing a collection-like interface to access domain aggregates while abstracting away the details of event storage and retrieval. The `IRepository` interface ensures that all implementations provide consistent behavior for storing, retrieving, and managing aggregates.

## Event Sourcing and Repository

In event-sourced systems, the repository plays a critical role:

1. **Event Storage**: The repository persists events generated by aggregates to an event store
2. **Aggregate Reconstruction**: When loading an aggregate, the repository retrieves its events and replays them to reconstruct the aggregate's state
3. **Concurrency Control**: The repository manages optimistic concurrency through version checking
4. **Transaction Boundaries**: Repository operations typically define transaction boundaries in the domain
5. **Stream Naming**: The repository is responsible for consistent stream naming conventions

Unlike traditional repositories that store the current state of entities, event-sourced repositories store the complete history of events that led to the current state. This approach provides several benefits, including:

- **Complete Audit Trail**: Every state change is recorded as an event
- **Temporal Queries**: The ability to reconstruct the state of an aggregate at any point in time
- **Event Replay**: The ability to replay events for debugging or analysis
- **Event Processing**: Events can be processed by other components for various purposes (e.g., building read models)
- **Correlation Tracking**: The ability to track related events across multiple aggregates and services

**Namespace**: `ReactiveDomain.Foundation`  
**Assembly**: `ReactiveDomain.Foundation.dll`

```csharp
public interface IRepository
{
    bool TryGetById<TAggregate>(Guid id, out TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
    TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource;
    void Update<TAggregate>(ref TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
    void Save(IEventSource aggregate);
    void Delete(IEventSource aggregate);
    void HardDelete(IEventSource aggregate);
}
```

## Methods

### TryGetById<TAggregate>

Attempts to retrieve an aggregate by its ID. This method provides a non-throwing alternative to `GetById` when you need to check for the existence of an aggregate without handling exceptions.

```csharp
bool TryGetById<TAggregate>(Guid id, out TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to retrieve. Must be a class that implements `IEventSource`.

**Parameters**:
- `id` (`System.Guid`): The ID of the aggregate to retrieve.
- `aggregate` (`TAggregate`): When this method returns, contains the aggregate with the specified ID, if found; otherwise, the default value for the type of the `aggregate` parameter.
- `version` (`System.Int32`, optional): The version of the aggregate to retrieve. Defaults to `int.MaxValue`, which retrieves the latest version.

**Returns**: `System.Boolean` - `true` if the aggregate was found; otherwise, `false`.

**Example**:
```csharp
// Try to retrieve an account by ID
Account account;
if (repository.TryGetById(accountId, out account))
{
    // Account exists, proceed with operations
    decimal balance = account.GetBalance();
    Console.WriteLine($"Account found with balance: {balance}");
}
else
{
    // Account doesn't exist, handle accordingly
    Console.WriteLine("Account not found");
}
```

**Remarks**: This method attempts to retrieve an aggregate by its ID. If the aggregate is not found, it returns `false` and sets `aggregate` to `null`. This is useful when you want to check if an aggregate exists without throwing exceptions.

### GetById<TAggregate>

Retrieves an aggregate by its ID. This is the primary method for loading aggregates from the repository.

```csharp
TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to retrieve. Must be a class that implements `IEventSource`.

**Parameters**:
- `id` (`System.Guid`): The ID of the aggregate to retrieve.
- `version` (`System.Int32`, optional): The version of the aggregate to retrieve. Defaults to `int.MaxValue`, which retrieves the latest version.

**Returns**: `TAggregate` - The aggregate with the specified ID.

**Exceptions**:
- `ReactiveDomain.AggregateNotFoundException`: Thrown when the aggregate with the specified ID is not found.
- `ReactiveDomain.AggregateDeletedException`: Thrown when the aggregate with the specified ID has been deleted.

**Example**:
```csharp
// Retrieve an account by ID
try
{
    var account = repository.GetById<Account>(accountId);
    
    // Perform operations on the account
    decimal balance = account.GetBalance();
    Console.WriteLine($"Account balance: {balance}");
    
    if (balance > 0)
    {
        account.Withdraw(balance);
        repository.Save(account);
    }
}
catch (AggregateNotFoundException)
{
    Console.WriteLine("Account not found");
}
catch (AggregateDeletedException)
{
    Console.WriteLine("Account has been deleted");
}
```

**Remarks**: This method retrieves an aggregate by its ID. If the aggregate is not found or has been deleted, it throws an exception. Use this method when you expect the aggregate to exist and want to handle exceptions for specific error cases.

### Update<TAggregate>

Updates an aggregate with events from the repository. This method is used to refresh an aggregate with the latest events from the event store, which is useful in scenarios where the aggregate might have been modified by another process.

```csharp
void Update<TAggregate>(ref TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to update. Must be a class that implements `IEventSource`.

**Parameters**:
- `aggregate` (`TAggregate`): The aggregate to update. This parameter is passed by reference and will be updated with the latest events.
- `version` (`System.Int32`, optional): The version to update the aggregate to. Defaults to `int.MaxValue`, which updates to the latest version.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `System.InvalidOperationException`: Thrown when the version is less than or equal to 0.
- `ReactiveDomain.AggregateNotFoundException`: Thrown when the aggregate with the specified ID is not found.
- `ReactiveDomain.AggregateDeletedException`: Thrown when the aggregate with the specified ID has been deleted.
- `ReactiveDomain.AggregateVersionException`: Thrown when the specified version does not match the expected version.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Perform some long-running operation
PerformLongRunningOperation();

// Update the account with the latest events before proceeding
// This ensures we have the most up-to-date state
try
{
    repository.Update(ref account);
    
    // Now we can safely perform operations on the updated account
    if (account.GetBalance() >= amount)
    {
        account.Withdraw(amount);
        repository.Save(account);
    }
}
catch (AggregateVersionException)
{
    Console.WriteLine("The account was modified concurrently");
}
```

**Remarks**: This method updates an aggregate with events from the repository. It loads events from the repository and applies them to the aggregate. This is useful when you need to ensure that you're working with the most up-to-date state of an aggregate before performing operations on it.

### Save

Saves an aggregate to the repository. This method persists the new events generated by the aggregate to the event store.

```csharp
void Save(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to save.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Create a new account
var account = new Account(Guid.NewGuid());

// Perform operations on the account
account.Deposit(1000);
account.Withdraw(500);

// Save the account to the repository
try
{
    repository.Save(account);
    Console.WriteLine("Account saved successfully");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}
```

**Remarks**: This method saves an aggregate to the repository. It takes the events from the aggregate and appends them to the event stream in the repository. If the aggregate's expected version does not match the version in the repository, it throws an `AggregateVersionException`, indicating a concurrent modification.

### Delete

Marks an aggregate as deleted in the repository. This method does not physically remove the aggregate from the event store but appends a deletion event to its stream.

```csharp
void Delete(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to delete.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Mark the account as deleted
try
{
    repository.Delete(account);
    Console.WriteLine("Account marked as deleted");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}

// Attempting to retrieve the account now will throw AggregateDeletedException
try
{
    var deletedAccount = repository.GetById<Account>(accountId);
}
catch (AggregateDeletedException)
{
    Console.WriteLine("Account has been deleted");
}
```

**Remarks**: This method marks an aggregate as deleted in the repository. It appends a deletion event to the event stream. The aggregate can still be retrieved, but will be marked as deleted, and attempts to retrieve it with `GetById` will throw an `AggregateDeletedException`.

### HardDelete

Permanently deletes an aggregate from the repository. This method physically removes the aggregate's event stream from the event store.

```csharp
void HardDelete(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to delete.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Permanently delete the account
try
{
    repository.HardDelete(account);
    Console.WriteLine("Account permanently deleted");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}

// Attempting to retrieve the account now will throw AggregateNotFoundException
try
{
    var deletedAccount = repository.GetById<Account>(accountId);
}
catch (AggregateNotFoundException)
{
    Console.WriteLine("Account not found (was permanently deleted)");
}
```

**Remarks**: This method permanently deletes an aggregate from the repository. It removes the event stream from the repository. The aggregate cannot be retrieved after this operation. Use this method with caution, as it permanently removes data from the system.

## Usage

### Basic Repository Operations

The `IRepository` interface is used to store and retrieve event-sourced aggregates. It is typically implemented by the `StreamStoreRepository` class, which stores events in an event store. Here's a comprehensive example of using a repository in a typical application scenario:

```csharp
// Create a repository with dependency injection (preferred approach)
public class AccountService
{
    private readonly IRepository _repository;
    private readonly IEventPublisher _eventPublisher;
    
    public AccountService(IRepository repository, IEventPublisher eventPublisher)
    {
        _repository = repository;
        _eventPublisher = eventPublisher;
    }
    
    public void CreateAccount(CreateAccount command)
    {
        // Check if account already exists
        Account account;
        if (_repository.TryGetById(command.AccountId, out account))
        {
            throw new InvalidOperationException($"Account {command.AccountId} already exists");
        }
        
        // Create new account
        account = new Account(command.AccountId, command);
        
        // Save the aggregate
        _repository.Save(account);
        
        // Publish events for read model updates and integration
        var events = account.TakeEvents();
        foreach (var @event in events)
        {
            _eventPublisher.Publish(@event);
        }
    }
    
    public void DepositFunds(DepositFunds command)
    {
        // Get the account
        var account = _repository.GetById<Account>(command.AccountId);
        
        // Process the command
        account.Deposit(command.Amount, command.Reference, command);
        
        // Save the account
        _repository.Save(account);
        
        // Publish events
        var events = account.TakeEvents();
        foreach (var @event in events)
        {
            _eventPublisher.Publish(@event);
        }
    }
    
    public decimal GetAccountBalance(Guid accountId)
    {
        var account = _repository.GetById<Account>(accountId);
        return account.GetBalance();
    }
}
```

### Integration with Command Handlers

Repositories are typically used within command handlers in a CQRS architecture. Here's an example of a modern command handler that uses a repository with proper correlation tracking:

```csharp
public class AccountCommandHandler : 
    ICommandHandler<CreateAccount>,
    ICommandHandler<DepositFunds>,
    ICommandHandler<WithdrawFunds>,
    ICommandHandler<CloseAccount>
{
    private readonly ICorrelatedRepository _repository;
    private readonly IEventPublisher _eventPublisher;
    
    public AccountCommandHandler(ICorrelatedRepository repository, IEventPublisher eventPublisher)
    {
        _repository = repository;
        _eventPublisher = eventPublisher;
    }
    
    public void Handle(CreateAccount command)
    {
        // Check if account already exists
        Account account;
        if (_repository.TryGetById(command.AccountId, out account, command))
        {
            throw new InvalidOperationException($"Account {command.AccountId} already exists");
        }
        
        // Create new account using the command constructor pattern
        account = new Account(command.AccountId, command);
        
        try
        {
            // Save the account
            _repository.Save(account);
            
            // Publish domain events to the event bus
            var events = account.TakeEvents();
            foreach (var @event in events)
            {
                _eventPublisher.Publish(@event);
            }
        }
        catch (AggregateVersionException ex)
        {
            // Log the concurrency conflict
            throw new CommandProcessingException(
                $"Concurrent modification detected for account {command.AccountId}", 
                ex, 
                command);
        }
    }
    
    public void Handle(DepositFunds command)
    {
        try
        {
            // Get the account with correlation
            var account = _repository.GetById<Account>(command.AccountId, command);
            
            // Process the command
            account.Deposit(command.Amount, command.Reference, command);
            
            // Save the account
            _repository.Save(account);
            
            // Publish domain events
            var events = account.TakeEvents();
            foreach (var @event in events)
            {
                _eventPublisher.Publish(@event);
            }
        }
        catch (AggregateNotFoundException)
        {
            throw new CommandProcessingException(
                $"Account {command.AccountId} not found", 
                null, 
                command);
        }
        catch (AggregateVersionException ex)
        {
            throw new CommandProcessingException(
                $"Concurrent modification detected for account {command.AccountId}", 
                ex, 
                command);
        }
        catch (Exception ex) when (!(ex is CommandProcessingException))
        {
            throw new CommandProcessingException(
                $"Error processing deposit for account {command.AccountId}", 
                ex, 
                command);
        }
    }
    
    // Additional handlers for other commands...
}
```

### Handling Concurrency Conflicts

Concurrency conflicts occur when multiple processes attempt to modify the same aggregate simultaneously. Here's a modern approach to handling concurrency conflicts with proper retry logic and correlation tracking:

```csharp
public class TransferFundsHandler : ICommandHandler<TransferFunds>
{
    private readonly ICorrelatedRepository _repository;
    private readonly IEventPublisher _eventPublisher;
    private readonly ILogger<TransferFundsHandler> _logger;
    private readonly int _maxRetries = 3;
    
    public TransferFundsHandler(
        ICorrelatedRepository repository, 
        IEventPublisher eventPublisher,
        ILogger<TransferFundsHandler> logger)
    {
        _repository = repository;
        _eventPublisher = eventPublisher;
        _logger = logger;
    }
    
    public void Handle(TransferFunds command)
    {
        int retryCount = 0;
        bool success = false;
        
        while (!success && retryCount < _maxRetries)
        {
            try
            {
                // Load both accounts with correlation
                var sourceAccount = _repository.GetById<Account>(command.SourceAccountId, command);
                var targetAccount = _repository.GetById<Account>(command.TargetAccountId, command);
                
                // Create a transfer record to track the operation
                var transfer = new Transfer(Guid.NewGuid(), command);
                transfer.Initialize(
                    command.SourceAccountId, 
                    command.TargetAccountId, 
                    command.Amount, 
                    command.Reference, 
                    command);
                
                // Execute the transfer
                sourceAccount.Withdraw(command.Amount, command.Reference, command);
                targetAccount.Deposit(command.Amount, command.Reference, command);
                transfer.MarkAsCompleted(command);
                
                // Save all aggregates in a specific order to minimize deadlocks
                _repository.Save(transfer);      // Save transfer record first
                _repository.Save(sourceAccount); // Save source account (most likely to fail)
                _repository.Save(targetAccount); // Save target account
                
                // Publish all events
                PublishEvents(transfer.TakeEvents());
                PublishEvents(sourceAccount.TakeEvents());
                PublishEvents(targetAccount.TakeEvents());
                
                success = true;
                _logger.LogInformation(
                    "Transfer {TransferId} completed: {Amount} from {SourceId} to {TargetId}",
                    transfer.Id, command.Amount, command.SourceAccountId, command.TargetAccountId);
            }
            catch (AggregateVersionException ex)
            {
                retryCount++;
                
                if (retryCount >= _maxRetries)
                {
                    _logger.LogWarning(
                        "Max retries reached for transfer from {SourceId} to {TargetId}",
                        command.SourceAccountId, command.TargetAccountId);
                    throw new CommandProcessingException(
                        "Transfer failed due to concurrent modifications", ex, command);
                }
                
                _logger.LogInformation(
                    "Concurrency conflict detected, retrying transfer (attempt {RetryCount}/{MaxRetries})",
                    retryCount, _maxRetries);
                
                // Add a small delay with jitter to reduce contention
                var delay = (int)(Math.Pow(2, retryCount) * 100 + new Random().Next(50));
                Thread.Sleep(delay);
            }
            catch (Exception ex) when (!(ex is CommandProcessingException))
            {
                _logger.LogError(ex, "Error processing transfer");
                throw new CommandProcessingException("Transfer failed", ex, command);
            }
        }
    }
    
    private void PublishEvents(IEnumerable<object> events)
    {
        foreach (var @event in events)
        {
            _eventPublisher.Publish(@event);
        }
    }
}
```

## Best Practices

### Repository Design

1. **Use Dependency Injection**: Always inject repositories into services and command handlers rather than creating them directly.

2. **Prefer ICorrelatedRepository**: Use `ICorrelatedRepository` instead of `IRepository` to ensure proper correlation tracking across the entire system.

3. **Consistent Stream Naming**: Use a consistent stream naming convention, typically `{AggregateType}-{AggregateId}`, to avoid collisions and make debugging easier.

4. **Optimistic Concurrency**: Always handle `AggregateVersionException` with appropriate retry logic or user feedback.

5. **Transactional Boundaries**: Treat each repository save operation as a transaction boundary. If you need to save multiple aggregates atomically, consider using a process manager or saga.

6. **Event Publishing**: Always publish events after successful repository operations to update read models and trigger integrations.

7. **Soft Deletion**: Prefer `Delete` (soft delete) over `HardDelete` to maintain a complete audit trail. Only use `HardDelete` for regulatory compliance (e.g., GDPR) or data lifecycle management.

8. **Exception Wrapping**: Wrap repository exceptions in domain-specific exceptions that provide context about the failed operation.

### Performance Optimization

1. **Snapshot Support**: Implement snapshot support for aggregates with long event histories to improve loading performance.

2. **Batched Event Publishing**: Consider batching event publishing for better throughput, especially in high-volume scenarios.

3. **Asynchronous Operations**: Implement and use asynchronous repository methods (`GetByIdAsync`, `SaveAsync`) for better scalability.

4. **Caching Strategy**: Implement a short-lived cache for frequently accessed aggregates, but ensure cache invalidation on updates.

5. **Stream Size Management**: Monitor stream sizes and implement strategies to deal with large streams (e.g., archiving, snapshots, or stream splitting).

6. **Bulk Loading**: Optimize for scenarios where multiple aggregates need to be loaded by implementing batch loading methods.

### Testing Strategies

1. **In-Memory Repository**: Use an in-memory repository implementation for unit testing command handlers and domain services.

2. **Test-Specific Events**: Create test-specific event factories to make tests more readable and maintainable.

3. **Event Stream Verification**: Verify the complete sequence of events produced by an operation, not just the final state.

4. **Concurrency Simulation**: Test concurrent modifications by simulating version conflicts in unit tests.

5. **Repository Decorators**: Use the decorator pattern to add cross-cutting concerns like logging, metrics, and caching to repositories.

## Common Pitfalls

### Design and Architecture Issues

1. **Missing Correlation**: Not using `ICorrelatedRepository` leads to lost correlation tracking, making it difficult to trace business transactions across the system.

2. **Repository in Domain Model**: Referencing repositories directly in domain entities violates the separation of concerns principle. Repositories should only be used in command handlers and domain services.

3. **Aggregate Boundaries**: Creating aggregates that are too large or too small. Aggregates should be designed around transactional consistency boundaries.

4. **Direct State Modification**: Modifying aggregate state directly instead of through events breaks the event sourcing pattern and loses the audit trail.

5. **Missing Domain Events**: Not raising domain events for important state changes, leading to incomplete audit trails and integration issues.

6. **Leaking Implementation Details**: Exposing repository implementation details (like stream names or serialization formats) to clients.

### Implementation Pitfalls

1. **Inconsistent Stream Naming**: Using different stream naming conventions across the application, leading to confusion and potential collisions.

2. **Event Schema Evolution**: Not handling changes to event schemas over time, causing deserialization errors when loading older events.

3. **Missing Retry Logic**: Not implementing proper retry logic for handling concurrency exceptions, leading to poor user experience.

4. **Excessive Event Data**: Including too much data in events, causing performance issues with serialization and storage.

5. **Ignoring Expected Version**: Not setting or checking the `ExpectedVersion` property when saving aggregates, bypassing optimistic concurrency control.

6. **Circular Event References**: Including circular references in event data, causing serialization issues.

7. **Inefficient Aggregate Loading**: Loading the entire event history when only a specific version or a subset of events is needed.

### CQRS and Event Processing Issues

1. **Missing Event Publishing**: Forgetting to publish events after saving aggregates, causing read models to become stale.

2. **Synchronous Read Model Updates**: Updating read models synchronously within the command handling process, slowing down command processing.

3. **Event Ordering**: Not preserving the order of events when publishing to event handlers, causing inconsistent read models.

4. **Command-Side Queries**: Performing complex queries on the command side instead of using dedicated read models.

5. **Event Replay Impact**: Not considering the performance impact of replaying events when designing event handlers and projections.

6. **Missing Idempotency**: Not making event handlers idempotent, causing issues when events are processed multiple times.

## Advanced Scenarios

### Event Upcasting

Event upcasting is the process of converting events from an older version to a newer version during the loading process. This is useful when the structure of events changes over time:

```csharp
public class UpcastingRepository : IRepository
{
    private readonly IRepository _innerRepository;
    private readonly IEventUpcastingService _upcastingService;
    
    public UpcastingRepository(IRepository innerRepository, IEventUpcastingService upcastingService)
    {
        _innerRepository = innerRepository;
        _upcastingService = upcastingService;
    }
    
    public TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource
    {
        var aggregate = _innerRepository.GetById<TAggregate>(id, version);
        
        // Upcasting events if needed
        var events = aggregate.TakeEvents();
        var upcastedEvents = _upcastingService.Upcast(events);
        
        // Recreate the aggregate with upcasted events
        var newAggregate = Activator.CreateInstance(typeof(TAggregate), id) as TAggregate;
        newAggregate.RestoreFromEvents(upcastedEvents);
        
        return newAggregate;
    }
    
    // Implement other methods...
}
```

### Snapshot Integration

Snapshots can significantly improve the performance of loading aggregates with many events:

```csharp
public class SnapshotRepository : IRepository
{
    private readonly IRepository _innerRepository;
    private readonly ISnapshotStore _snapshotStore;
    
    public SnapshotRepository(IRepository innerRepository, ISnapshotStore snapshotStore)
    {
        _innerRepository = innerRepository;
        _snapshotStore = snapshotStore;
    }
    
    public TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource
    {
        // Try to get a snapshot
        var snapshotSource = typeof(TAggregate).GetInterfaces().Contains(typeof(ISnapshotSource));
        
        if (snapshotSource)
        {
            var snapshot = _snapshotStore.GetLatestSnapshot(id);
            
            if (snapshot != null)
            {
                // Create aggregate and restore from snapshot
                var aggregate = Activator.CreateInstance(typeof(TAggregate), id) as TAggregate;
                (aggregate as ISnapshotSource).RestoreFromSnapshot(snapshot.State);
                
                // Get events after the snapshot version
                var events = _innerRepository.GetEventsAfterVersion(id, snapshot.Version, version);
                aggregate.RestoreFromEvents(events);
                
                return aggregate;
            }
        }
        
        // Fall back to regular loading
        return _innerRepository.GetById<TAggregate>(id, version);
    }
    
    // Implement other methods...
}
```

## Related Types

- [IEventSource](ievent-source.md): The interface for event-sourced entities
- [AggregateRoot](aggregate-root.md): Base class for domain aggregates
- [StreamStoreRepository](stream-store-repository.md): Implementation of `IRepository`
- [ICorrelatedRepository](icorrelated-repository.md): Repository with correlation support
- [EventDrivenStateMachine](event-driven-state-machine.md): Base class for event-sourced entities
- [Command](command.md): Messages that trigger state changes in aggregates
- [Event](event.md): Messages that represent state changes in aggregates
- [ISnapshotSource](isnapshot-source.md): Interface for aggregates that support snapshots

---

**Navigation**:
- [← Previous: EventDrivenStateMachine](./event-driven-state-machine.md)
- [↑ Back to Top](#irepository-interface)
- [→ Next: ICorrelatedRepository](./icorrelated-repository.md)
