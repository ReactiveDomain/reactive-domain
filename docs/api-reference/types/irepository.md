# IRepository Interface

[← Back to API Reference](../README.md) | [← Back to Table of Contents](../../README.md)

## Overview

The `IRepository` interface defines the contract for repositories that store and retrieve event-sourced aggregates in Reactive Domain. It is a fundamental component in the event sourcing pattern, serving as the bridge between domain aggregates and the underlying event store.

Repositories in Reactive Domain follow the Repository pattern from Domain-Driven Design (DDD), providing a collection-like interface to access domain aggregates while abstracting away the details of event storage and retrieval. The `IRepository` interface ensures that all implementations provide consistent behavior for storing, retrieving, and managing aggregates.

## Event Sourcing and Repository

In event-sourced systems, the repository plays a critical role:

1. **Event Storage**: The repository persists events generated by aggregates to an event store
2. **Aggregate Reconstruction**: When loading an aggregate, the repository retrieves its events and replays them to reconstruct the aggregate's state
3. **Concurrency Control**: The repository manages optimistic concurrency through version checking
4. **Transaction Boundaries**: Repository operations typically define transaction boundaries in the domain

Unlike traditional repositories that store the current state of entities, event-sourced repositories store the complete history of events that led to the current state. This approach provides several benefits, including:

- **Complete Audit Trail**: Every state change is recorded as an event
- **Temporal Queries**: The ability to reconstruct the state of an aggregate at any point in time
- **Event Replay**: The ability to replay events for debugging or analysis
- **Event Processing**: Events can be processed by other components for various purposes (e.g., building read models)

**Namespace**: `ReactiveDomain.Foundation`  
**Assembly**: `ReactiveDomain.Foundation.dll`

```csharp
public interface IRepository
{
    bool TryGetById<TAggregate>(Guid id, out TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
    TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource;
    void Update<TAggregate>(ref TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
    void Save(IEventSource aggregate);
    void Delete(IEventSource aggregate);
    void HardDelete(IEventSource aggregate);
}
```

## Methods

### TryGetById<TAggregate>

Attempts to retrieve an aggregate by its ID. This method provides a non-throwing alternative to `GetById` when you need to check for the existence of an aggregate without handling exceptions.

```csharp
bool TryGetById<TAggregate>(Guid id, out TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to retrieve. Must be a class that implements `IEventSource`.

**Parameters**:
- `id` (`System.Guid`): The ID of the aggregate to retrieve.
- `aggregate` (`TAggregate`): When this method returns, contains the aggregate with the specified ID, if found; otherwise, the default value for the type of the `aggregate` parameter.
- `version` (`System.Int32`, optional): The version of the aggregate to retrieve. Defaults to `int.MaxValue`, which retrieves the latest version.

**Returns**: `System.Boolean` - `true` if the aggregate was found; otherwise, `false`.

**Example**:
```csharp
// Try to retrieve an account by ID
Account account;
if (repository.TryGetById(accountId, out account))
{
    // Account exists, proceed with operations
    decimal balance = account.GetBalance();
    Console.WriteLine($"Account found with balance: {balance}");
}
else
{
    // Account doesn't exist, handle accordingly
    Console.WriteLine("Account not found");
}
```

**Remarks**: This method attempts to retrieve an aggregate by its ID. If the aggregate is not found, it returns `false` and sets `aggregate` to `null`. This is useful when you want to check if an aggregate exists without throwing exceptions.

### GetById<TAggregate>

Retrieves an aggregate by its ID. This is the primary method for loading aggregates from the repository.

```csharp
TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to retrieve. Must be a class that implements `IEventSource`.

**Parameters**:
- `id` (`System.Guid`): The ID of the aggregate to retrieve.
- `version` (`System.Int32`, optional): The version of the aggregate to retrieve. Defaults to `int.MaxValue`, which retrieves the latest version.

**Returns**: `TAggregate` - The aggregate with the specified ID.

**Exceptions**:
- `ReactiveDomain.AggregateNotFoundException`: Thrown when the aggregate with the specified ID is not found.
- `ReactiveDomain.AggregateDeletedException`: Thrown when the aggregate with the specified ID has been deleted.

**Example**:
```csharp
// Retrieve an account by ID
try
{
    var account = repository.GetById<Account>(accountId);
    
    // Perform operations on the account
    decimal balance = account.GetBalance();
    Console.WriteLine($"Account balance: {balance}");
    
    if (balance > 0)
    {
        account.Withdraw(balance);
        repository.Save(account);
    }
}
catch (AggregateNotFoundException)
{
    Console.WriteLine("Account not found");
}
catch (AggregateDeletedException)
{
    Console.WriteLine("Account has been deleted");
}
```

**Remarks**: This method retrieves an aggregate by its ID. If the aggregate is not found or has been deleted, it throws an exception. Use this method when you expect the aggregate to exist and want to handle exceptions for specific error cases.

### Update<TAggregate>

Updates an aggregate with events from the repository. This method is used to refresh an aggregate with the latest events from the event store, which is useful in scenarios where the aggregate might have been modified by another process.

```csharp
void Update<TAggregate>(ref TAggregate aggregate, int version = int.MaxValue) where TAggregate : class, IEventSource;
```

**Type Parameters**:
- `TAggregate`: The type of the aggregate to update. Must be a class that implements `IEventSource`.

**Parameters**:
- `aggregate` (`TAggregate`): The aggregate to update. This parameter is passed by reference and will be updated with the latest events.
- `version` (`System.Int32`, optional): The version to update the aggregate to. Defaults to `int.MaxValue`, which updates to the latest version.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `System.InvalidOperationException`: Thrown when the version is less than or equal to 0.
- `ReactiveDomain.AggregateNotFoundException`: Thrown when the aggregate with the specified ID is not found.
- `ReactiveDomain.AggregateDeletedException`: Thrown when the aggregate with the specified ID has been deleted.
- `ReactiveDomain.AggregateVersionException`: Thrown when the specified version does not match the expected version.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Perform some long-running operation
PerformLongRunningOperation();

// Update the account with the latest events before proceeding
// This ensures we have the most up-to-date state
try
{
    repository.Update(ref account);
    
    // Now we can safely perform operations on the updated account
    if (account.GetBalance() >= amount)
    {
        account.Withdraw(amount);
        repository.Save(account);
    }
}
catch (AggregateVersionException)
{
    Console.WriteLine("The account was modified concurrently");
}
```

**Remarks**: This method updates an aggregate with events from the repository. It loads events from the repository and applies them to the aggregate. This is useful when you need to ensure that you're working with the most up-to-date state of an aggregate before performing operations on it.

### Save

Saves an aggregate to the repository. This method persists the new events generated by the aggregate to the event store.

```csharp
void Save(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to save.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Create a new account
var account = new Account(Guid.NewGuid());

// Perform operations on the account
account.Deposit(1000);
account.Withdraw(500);

// Save the account to the repository
try
{
    repository.Save(account);
    Console.WriteLine("Account saved successfully");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}
```

**Remarks**: This method saves an aggregate to the repository. It takes the events from the aggregate and appends them to the event stream in the repository. If the aggregate's expected version does not match the version in the repository, it throws an `AggregateVersionException`, indicating a concurrent modification.

### Delete

Marks an aggregate as deleted in the repository. This method does not physically remove the aggregate from the event store but appends a deletion event to its stream.

```csharp
void Delete(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to delete.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Mark the account as deleted
try
{
    repository.Delete(account);
    Console.WriteLine("Account marked as deleted");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}

// Attempting to retrieve the account now will throw AggregateDeletedException
try
{
    var deletedAccount = repository.GetById<Account>(accountId);
}
catch (AggregateDeletedException)
{
    Console.WriteLine("Account has been deleted");
}
```

**Remarks**: This method marks an aggregate as deleted in the repository. It appends a deletion event to the event stream. The aggregate can still be retrieved, but will be marked as deleted, and attempts to retrieve it with `GetById` will throw an `AggregateDeletedException`.

### HardDelete

Permanently deletes an aggregate from the repository. This method physically removes the aggregate's event stream from the event store.

```csharp
void HardDelete(IEventSource aggregate);
```

**Parameters**:
- `aggregate` (`ReactiveDomain.IEventSource`): The aggregate to delete.

**Exceptions**:
- `System.ArgumentNullException`: Thrown when `aggregate` is `null`.
- `ReactiveDomain.AggregateVersionException`: Thrown when the aggregate's expected version does not match the version in the repository.

**Example**:
```csharp
// Retrieve an account
var account = repository.GetById<Account>(accountId);

// Permanently delete the account
try
{
    repository.HardDelete(account);
    Console.WriteLine("Account permanently deleted");
}
catch (AggregateVersionException)
{
    Console.WriteLine("Concurrent modification detected");
    // Handle the concurrency conflict
}

// Attempting to retrieve the account now will throw AggregateNotFoundException
try
{
    var deletedAccount = repository.GetById<Account>(accountId);
}
catch (AggregateNotFoundException)
{
    Console.WriteLine("Account not found (was permanently deleted)");
}
```

**Remarks**: This method permanently deletes an aggregate from the repository. It removes the event stream from the repository. The aggregate cannot be retrieved after this operation. Use this method with caution, as it permanently removes data from the system.

## Usage

### Basic Repository Operations

The `IRepository` interface is used to store and retrieve event-sourced aggregates. It is typically implemented by the `StreamStoreRepository` class, which stores events in an event store. Here's a comprehensive example of using a repository in a typical application scenario:

```csharp
// Create a repository
var streamNameBuilder = new PrefixedCamelCaseStreamNameBuilder();
var eventStoreConnection = new StreamStoreConnection("MyApp", connectionSettings, "localhost", 1113);
var serializer = new JsonMessageSerializer();
var repository = new StreamStoreRepository(streamNameBuilder, eventStoreConnection, serializer);

// Create a new aggregate
var accountId = Guid.NewGuid();
var account = new Account(accountId);
account.Deposit(1000, command);

// Save the aggregate
repository.Save(account);
Console.WriteLine($"Created account {accountId} with initial deposit of $1000");

// Retrieve the aggregate
var retrievedAccount = repository.GetById<Account>(accountId);
Console.WriteLine($"Retrieved account balance: ${retrievedAccount.GetBalance()}");

// Perform operations on the aggregate
retrievedAccount.Withdraw(500, command);
Console.WriteLine($"Withdrew $500, new balance: ${retrievedAccount.GetBalance()}");

// Save the updated aggregate
repository.Save(retrievedAccount);
Console.WriteLine("Saved account after withdrawal");

// Update the aggregate with the latest events
repository.Update(ref retrievedAccount);
Console.WriteLine($"Updated account balance: ${retrievedAccount.GetBalance()}");

// Delete the aggregate (soft delete)
repository.Delete(retrievedAccount);
Console.WriteLine("Deleted account (soft delete)");

// Hard delete the aggregate (permanent deletion)
// repository.HardDelete(retrievedAccount);
// Console.WriteLine("Permanently deleted account");
```

### Integration with Command Handlers

Repositories are typically used within command handlers in a CQRS architecture. Here's an example of a command handler that uses a repository:

```csharp
public class AccountCommandHandler : 
    ICommandHandler<CreateAccount>,
    ICommandHandler<DepositFunds>,
    ICommandHandler<WithdrawFunds>,
    ICommandHandler<CloseAccount>
{
    private readonly IRepository _repository;
    private readonly IEventBus _eventBus;
    
    public AccountCommandHandler(IRepository repository, IEventBus eventBus)
    {
        _repository = repository;
        _eventBus = eventBus;
    }
    
    public void Handle(CreateAccount command)
    {
        // Check if account already exists
        Account account;
        if (_repository.TryGetById(command.AccountId, out account))
        {
            throw new InvalidOperationException($"Account {command.AccountId} already exists");
        }
        
        // Create new account
        account = new Account(command.AccountId);
        account.CreateAccount(command.AccountNumber, command.InitialDeposit, command);
        
        // Save the account
        _repository.Save(account);
        
        // Publish domain events to the event bus
        foreach (var @event in account.TakeEvents())
        {
            _eventBus.Publish(@event);
        }
    }
    
    public void Handle(DepositFunds command)
    {
        // Get the account
        var account = _repository.GetById<Account>(command.AccountId);
        
        // Process the command
        account.Deposit(command.Amount, command);
        
        // Save the account
        _repository.Save(account);
        
        // Publish domain events
        foreach (var @event in account.TakeEvents())
        {
            _eventBus.Publish(@event);
        }
    }
    
    // Additional handlers for other commands...
}
```

### Handling Concurrency Conflicts

Concurrency conflicts occur when multiple processes attempt to modify the same aggregate simultaneously. Here's an example of handling concurrency conflicts:

```csharp
public void TransferFunds(TransferFunds command)
{
    var sourceAccount = _repository.GetById<Account>(command.SourceAccountId);
    var targetAccount = _repository.GetById<Account>(command.TargetAccountId);
    
    try
    {
        // Withdraw from source account
        sourceAccount.Withdraw(command.Amount, command);
        
        // Deposit to target account
        targetAccount.Deposit(command.Amount, command);
        
        // Save both accounts
        _repository.Save(sourceAccount);
        _repository.Save(targetAccount);
    }
    catch (AggregateVersionException ex)
    {
        // Handle concurrency conflict
        if (ex.AggregateId == command.SourceAccountId)
        {
            // Reload source account and retry
            sourceAccount = _repository.GetById<Account>(command.SourceAccountId);
            // Implement retry logic...
        }
        else
        {
            // Reload target account and retry
            targetAccount = _repository.GetById<Account>(command.TargetAccountId);
            // Implement retry logic...
        }
    }
}
```

## Best Practices

### Repository Design

1. **Optimistic Concurrency**: Always handle `AggregateVersionException` to manage concurrent modifications
2. **Aggregate Lifecycle**: Use `Delete` for logical deletion and `HardDelete` only when data must be permanently removed
3. **Version Management**: Use the `version` parameter in `GetById` and `Update` to work with specific versions of aggregates
4. **Error Handling**: Implement proper exception handling for repository operations
5. **Transaction Boundaries**: Consider repository operations as transaction boundaries in your domain
6. **Repository Abstraction**: Depend on the `IRepository` interface rather than concrete implementations
7. **Correlation Tracking**: Use `ICorrelatedRepository` when correlation information needs to be maintained

### Performance Considerations

1. **Snapshot Support**: Use snapshots for aggregates with many events to improve loading performance
2. **Batch Operations**: Consider batching operations when working with multiple aggregates
3. **Caching**: Implement caching strategies for frequently accessed aggregates
4. **Asynchronous Operations**: Use asynchronous repository implementations for better scalability
5. **Event Size**: Keep events small and focused to improve serialization and deserialization performance

### Testing

1. **In-Memory Repository**: Use an in-memory repository implementation for unit testing
2. **Test Doubles**: Create test doubles (mocks, stubs) for the repository interface
3. **Event Verification**: Verify that the correct events are saved to the repository
4. **Concurrency Testing**: Test concurrent operations to ensure proper handling of version conflicts
5. **Integration Testing**: Use a real repository implementation for integration testing

## Common Pitfalls

### Design Issues

1. **Ignoring Concurrency**: Failing to handle `AggregateVersionException` can lead to lost updates
2. **Large Aggregates**: Storing too many events in a single aggregate can impact performance
3. **Missing Version Checks**: Not checking versions when updating aggregates can lead to inconsistent state
4. **Hard Deletion Overuse**: Using `HardDelete` when `Delete` would be more appropriate
5. **Repository Leakage**: Allowing repository implementation details to leak into the domain model
6. **Missing Error Handling**: Not properly handling repository exceptions

### Implementation Challenges

1. **Event Schema Evolution**: Not handling changes to event schemas over time
2. **Event Ordering**: Not maintaining the correct order of events
3. **Event Serialization**: Issues with serializing and deserializing complex event structures
4. **Stream Name Collisions**: Using non-unique stream names for different aggregates
5. **Repository Dependencies**: Creating tight coupling between the repository and other components

### CQRS Integration Issues

1. **Read/Write Separation**: Not properly separating read and write repositories
2. **Event Publishing**: Forgetting to publish events after saving aggregates
3. **Command Validation**: Performing validation in the repository instead of in command handlers
4. **Event Replay**: Not considering the impact of event replay on performance
5. **Read Model Updates**: Not updating read models when events are saved

## Advanced Scenarios

### Event Upcasting

Event upcasting is the process of converting events from an older version to a newer version during the loading process. This is useful when the structure of events changes over time:

```csharp
public class UpcastingRepository : IRepository
{
    private readonly IRepository _innerRepository;
    private readonly IEventUpcastingService _upcastingService;
    
    public UpcastingRepository(IRepository innerRepository, IEventUpcastingService upcastingService)
    {
        _innerRepository = innerRepository;
        _upcastingService = upcastingService;
    }
    
    public TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource
    {
        var aggregate = _innerRepository.GetById<TAggregate>(id, version);
        
        // Upcasting events if needed
        var events = aggregate.TakeEvents();
        var upcastedEvents = _upcastingService.Upcast(events);
        
        // Recreate the aggregate with upcasted events
        var newAggregate = Activator.CreateInstance(typeof(TAggregate), id) as TAggregate;
        newAggregate.RestoreFromEvents(upcastedEvents);
        
        return newAggregate;
    }
    
    // Implement other methods...
}
```

### Snapshot Integration

Snapshots can significantly improve the performance of loading aggregates with many events:

```csharp
public class SnapshotRepository : IRepository
{
    private readonly IRepository _innerRepository;
    private readonly ISnapshotStore _snapshotStore;
    
    public SnapshotRepository(IRepository innerRepository, ISnapshotStore snapshotStore)
    {
        _innerRepository = innerRepository;
        _snapshotStore = snapshotStore;
    }
    
    public TAggregate GetById<TAggregate>(Guid id, int version = int.MaxValue) where TAggregate : class, IEventSource
    {
        // Try to get a snapshot
        var snapshotSource = typeof(TAggregate).GetInterfaces().Contains(typeof(ISnapshotSource));
        
        if (snapshotSource)
        {
            var snapshot = _snapshotStore.GetLatestSnapshot(id);
            
            if (snapshot != null)
            {
                // Create aggregate and restore from snapshot
                var aggregate = Activator.CreateInstance(typeof(TAggregate), id) as TAggregate;
                (aggregate as ISnapshotSource).RestoreFromSnapshot(snapshot.State);
                
                // Get events after the snapshot version
                var events = _innerRepository.GetEventsAfterVersion(id, snapshot.Version, version);
                aggregate.RestoreFromEvents(events);
                
                return aggregate;
            }
        }
        
        // Fall back to regular loading
        return _innerRepository.GetById<TAggregate>(id, version);
    }
    
    // Implement other methods...
}
```

## Related Types

- [IEventSource](ievent-source.md): The interface for event-sourced entities
- [AggregateRoot](aggregate-root.md): Base class for domain aggregates
- [StreamStoreRepository](stream-store-repository.md): Implementation of `IRepository`
- [ICorrelatedRepository](icorrelated-repository.md): Repository with correlation support
- [EventDrivenStateMachine](event-driven-state-machine.md): Base class for event-sourced entities
- [Command](command.md): Messages that trigger state changes in aggregates
- [Event](event.md): Messages that represent state changes in aggregates
- [ISnapshotSource](isnapshot-source.md): Interface for aggregates that support snapshots

---

**Navigation**:
- [← Previous: EventDrivenStateMachine](./event-driven-state-machine.md)
- [↑ Back to Top](#irepository-interface)
- [→ Next: ICorrelatedRepository](./icorrelated-repository.md)
